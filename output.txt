file: README.md
---
# Bouncing Shapes with Sound

This project simulates bouncing shapes within a defined boundary. Each shape is assigned a unique piano note that plays when the shape collides with the boundary. The shapes can grow, change color, and vary in speed. The game speed adjusts dynamically based on CPU usage to prevent crashes.

## Table of Contents

- [Features](#features)
- [Prerequisites](#prerequisites)
- [Installation](#installation)
- [Usage](#usage)
- [Directory Structure](#directory-structure)
- [Configuration](#configuration)
- [Scripts](#scripts)
- [Contributing](#contributing)
- [License](#license)

## Features

- Simulates multiple shapes (circle, rectangle, polygon) bouncing within a boundary.
- Shapes can grow, change color, and vary in speed.
- Each shape is assigned a unique piano note that plays upon collision with the boundary.
- Supports generating random scenarios with customizable parameters.
- Ability to record the simulation.
- Dynamic game speed adjustment based on CPU usage to prevent crashes.

## Prerequisites

- Python 3.7+
- `pydub` library
- `psutil` library
- `ffmpeg` for audio processing

## Installation

1. **Clone the repository:**

    ```bash
    git clone https://github.com/yourusername/bouncing-shapes-with-sound.git
    cd bouncing-shapes-with-sound
    ```

2. **Create a virtual environment and activate it:**

    ```bash
    python -m venv .venv
    source .venv/bin/activate
    ```

3. **Install the required packages:**

    ```bash
    pip install pydub numpy psutil
    ```

4. **Install `ffmpeg`:**
    - **On macOS:**
      ```bash
      brew install ffmpeg
      ```
    - **On Ubuntu:**
      ```bash
      sudo apt-get install ffmpeg
      ```
    - **On Windows:**
      Download and install `ffmpeg` from [ffmpeg.org](https://ffmpeg.org/download.html).

## Usage

### Running the Simulation

- **Run with default settings:**

    ```bash
    ./run
    ```

- **Run and generate random scenarios:**

    ```bash
    ./run-random
    ```

- **Run and generate a specific number of random scenarios:**

    ```bash
    ./run-random 20
    ```

- **Run with recording enabled:**

    ```bash
    ./run --record
    ```

### Generating Scenarios

- **Generate default number of scenarios (10):**

    ```bash
    ./generate-scenarios
    ```

- **Generate a specific number of scenarios:**

    ```bash
    ./generate-scenarios 20
    ```

## Directory Structure

```
bouncing-shapes-with-sound/
├── .venv/
├── base.py
├── boundary.py
├── display.py
├── generate-scenarios
├── generate_scenarios.py
├── README.md
├── recorder.py
├── run
├── run-random
├── scenarios.json
├── shape.py
└── sound.py
```

## Configuration

### `scenarios.json`

Each scenario in `scenarios.json` defines the boundary and shapes with their respective properties.

#### Example:

```json
{
    "scenarios": [
        {
            "name": "Scenario 1",
            "duration": 10,
            "rect_x": 100,
            "rect_y": 100,
            "rect_width": 400,
            "rect_height": 300,
            "shapes": [
                {
                    "shape": "circle",
                    "color_change": true,
                    "size_change": 2.5,
                    "speed_increase_factor": 1.03,
                    "growth_rate": 0.05,
                    "carrying_capacity": 250,
                    "sides_change": 0,
                    "initial_size": 30.0,
                    "initial_speed_x": 2.0,
                    "initial_speed_y": 3.0
                },
                {
                    "shape": "rectangle",
                    "color_change": false,
                    "size_change": 1.5,
                    "speed_increase_factor": 1.02,
                    "growth_rate": 0.04,
                    "carrying_capacity": 200,
                    "sides_change": 0,
                    "initial_size": 25.0,
                    "initial_speed_x": 3.0,
                    "initial_speed_y": 2.5
                }
            ]
        }
    ]
}
```

### Shape Properties

- `shape`: Type of shape (`circle`, `rectangle`, `polygon`).
- `color_change`: Whether the shape changes color upon collision.
- `size_change`: Amount by which the shape's size changes.
- `speed_increase_factor`: Factor by which the shape's speed increases upon collision.
- `growth_rate`: Rate at which the shape grows.
- `carrying_capacity`: Maximum size the shape can grow to.
- `sides_change`: Number of sides to change for polygons.
- `initial_size`: Initial size of the shape.
- `initial_speed_x`: Initial speed in the x-direction.
- `initial_speed_y`: Initial speed in the y-direction.

## Scripts

- `generate-scenarios`: Generates random scenarios.
- `run`: Runs the main script.
- `run-random`: Generates random scenarios and runs the main script.

## Contributing

1. Fork the repository.
2. Create a new branch: `git checkout -b feature-branch`.
3. Make your changes and commit them: `git commit -m 'Add some feature'`.
4. Push to the branch: `git push origin feature-branch`.
5. Open a pull request.

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.
---

file: base.py
---
import argparse
import json
import os
import time
from display import Display
from shape import Shape
from boundary import Boundary
from recorder import Recorder
from sound import foo, print_collisions
import psutil
import asyncio

def load_scenarios(file_path):
    with open(file_path, 'r') as file:
        data = json.load(file)
    return data["scenarios"]

async def run_scenario(config, output_dir, record, include_sound):
    display = Display(640, 480)
    boundary = Boundary(config["rect_x"], config["rect_y"], config["rect_width"], config["rect_height"])
    
    shapes = [Shape(shape_config) for shape_config in config["shapes"]]
    
    recorder = None
    output_file = None
    if record:
        output_file = os.path.join(output_dir, config["name"] + ".mp4")
        recorder = Recorder(640, 480, output_file)

    start_time = time.time()
    base_fps = 100
    while display.running and (time.time() - start_time < config["duration"]):
        display.handle_events()
        
        fps = base_fps

        for shape in shapes:
            shape.move()
            await shape.bounce(boundary)
        frame = display.update_display(shapes, boundary)
        if record:
            recorder.record_frame(display.window)
        display.tick(fps)
    
    if record:
        recorder.release()
    display.stop()
    
    # Collect collision data and pass it to foo()
    collision_data = []
    for shape in shapes:
        collision_data.extend(shape.get_collisions())
    if include_sound:
        foo(collision_data)
    print_collisions(collision_data)
    
    # Combine the recorded video with the generated audio if sound is included
    if record and include_sound:
        audio_file = "collision_sounds.wav"
        final_output_file = os.path.join(output_dir, config["name"] + "_with_audio.mp4")
        recorder.combine_video_audio(audio_file, final_output_file)
    elif record:
        final_output_file = output_file

def main(config_file, output_dir, record, include_sound):
    os.makedirs(output_dir, exist_ok=True)
    scenarios = load_scenarios(config_file)
    for config in scenarios:
        asyncio.run(run_scenario(config, output_dir, record, include_sound))

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run bouncing object scenarios.")
    parser.add_argument('--config', type=str, default='scenarios.json', help='Path to the JSON configuration file.')
    parser.add_argument('--output', type=str, default='output', help='Directory to save the output videos.')
    parser.add_argument('--record', action='store_true', help='Specify this flag to record the simulation.')
    parser.add_argument('--sound', action='store_true', help='Include sound in the recorded video.')
    args = parser.parse_args()
    main(args.config, args.output, args.record, args.sound)

---

file: boundary.py
---
class Boundary:
    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height

---

file: display.py
---
import pygame
import math

class Display:
    def __init__(self, width, height):
        pygame.init()
        self.width, self.height = width, height
        self.window = pygame.display.set_mode((self.width, self.height))
        pygame.display.set_caption("Bouncing Object ASMR")
        self.background_color = (0, 0, 0)
        self.clock = pygame.time.Clock()
        self.running = True

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False

    def update_display(self, shapes, boundary):
        self.window.fill(self.background_color)
        # Draw the boundary
        pygame.draw.rect(self.window, (255, 255, 255), (boundary.x, boundary.y, boundary.width, boundary.height), 2)
        # Draw each shape within the boundary
        for shape in shapes:
            if shape.shape == 'circle':
                pygame.draw.circle(self.window, shape.color, [int(coord) for coord in shape.position], int(shape.size))
            elif shape.shape == 'rectangle':
                pygame.draw.rect(self.window, shape.color, (shape.position[0] - shape.size, shape.position[1] - shape.size, shape.size * 2, shape.size * 2))
            elif shape.shape == 'polygon' and shape.sides:
                points = self.calculate_polygon_points(shape.position, shape.size, shape.sides)
                pygame.draw.polygon(self.window, shape.color, points)
        pygame.display.flip()
        return self.window.copy()

    def calculate_polygon_points(self, position, size, sides):
        points = []
        angle = 360 / sides
        for i in range(sides):
            x = position[0] + size * math.cos(math.radians(angle * i))
            y = position[1] + size * math.sin(math.radians(angle * i))
            points.append((x, y))
        return points

    def tick(self, fps):
        self.clock.tick(fps)

    def stop(self):
        pygame.quit()

---

file: generate-scenarios
---
#!/bin/bash

# Step 1: Activate the virtual environment
echo "Activating the virtual environment..."
source .venv/bin/activate

# Step 2: Run the generate_scenarios.py script with the provided argument
echo "Generating scenarios..."
if [ -z "$1" ]; then
    python generate_scenarios.py
else
    python generate_scenarios.py "$1"
fi

# Step 3: Deactivate the virtual environment
deactivate

echo "Scenario generation complete!"

---

file: generate_scenarios.py
---
import json
import random
import argparse

def generate_random_shape():
    shapes = ['circle', 'rectangle', 'polygon']
    shape = {
        "shape": random.choice(shapes),
        "color_change": random.choice([True, False]),
        "size_change": round(random.uniform(-5.0, 5.0), 2),
        "speed_increase_factor": round(random.uniform(1.01, 1.05), 2),
        "growth_rate": round(random.uniform(0.01, 0.1), 2),
        "carrying_capacity": round(random.uniform(50.0, 300.0), 2),
        "sides_change": random.randint(0, 3),
        "position_change": random.choice([True, False]),
        "initial_size": round(random.uniform(10.0, 50.0), 2),
        "initial_speed_x": round(random.uniform(1.0, 10.0), 2),
        "initial_speed_y": round(random.uniform(1.0, 10.0), 2)
    }
    return shape

def generate_random_scenario():
    scenario = {
        "name": f"Scenario {random.randint(1, 1000)}",
        "duration": random.randint(5, 20),
        "rect_x": random.randint(50, 150),
        "rect_y": random.randint(50, 150),
        "rect_width": random.randint(300, 500),
        "rect_height": random.randint(200, 400),
        "shapes": [generate_random_shape() for _ in range(random.randint(1, 5))]
    }
    return scenario

def generate_scenarios(num_scenarios):
    scenarios = {"scenarios": [generate_random_scenario() for _ in range(num_scenarios)]}
    with open('scenarios.json', 'w') as file:
        json.dump(scenarios, file, indent=4)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate random scenarios for bouncing objects.")
    parser.add_argument('num_scenarios', type=int, nargs='?', default=1, help='Number of scenarios to generate.')
    args = parser.parse_args()
    generate_scenarios(args.num_scenarios)

---

file: install
---
#!/bin/bash

# Step 1: Check if Python 3.11 is installed
if ! command -v python3.11 &>/dev/null; then
    echo "Python 3.11 is not installed. Please install Python 3.11."
    exit 1
fi

# Step 2: Create a virtual environment using Python 3.11
echo "Creating a virtual environment with Python 3.11..."
python3.11 -m venv .venv

# Step 3: Activate the virtual environment
echo "Activating the virtual environment..."
source .venv/bin/activate

# Step 4: Install required packages
echo "Installing required packages..."
pip install --upgrade pip
pip install -r requirements.txt

# Step 5: Deactivate the virtual environment
deactivate

echo "Installation complete!"

---

file: recorder.py
---
import cv2
import numpy as np
import pygame
from moviepy.editor import VideoFileClip, AudioFileClip
import os

class Recorder:
    def __init__(self, width, height, output_file):
        self.width = width
        self.height = height
        self.output_file = output_file
        self.fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        self.video_writer = cv2.VideoWriter(output_file, self.fourcc, 30.0, (width, height))

    def record_frame(self, surface):
        frame = pygame.surfarray.array3d(surface)
        frame = np.rot90(frame, 3)
        frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
        self.video_writer.write(frame)

    def release(self):
        self.video_writer.release()

    def combine_video_audio(self, audio_file, final_output_file):
        video_clip = VideoFileClip(self.output_file)
        audio_clip = AudioFileClip(audio_file)
        final_clip = video_clip.set_audio(audio_clip)
        final_clip.write_videofile(final_output_file, codec='libx264', audio_codec='aac')
        
        # Delete the original video file after combining
        os.remove(self.output_file)

---

file: requirements.txt
---
numpy
opencv-python
pygame
pydub
psutil
moviepy

---

file: run
---
#!/bin/bash

# Step 1: Activate the virtual environment
echo "Activating the virtual environment..."
source .venv/bin/activate

# Step 2: Run the main script with all provided arguments
echo "Running the main script..."
python base.py "$@"

# Step 3: Deactivate the virtual environment
deactivate

echo "Execution complete!"

---

file: run-random
---
#!/bin/bash

# Step 1: Generate random scenarios
echo "Generating random scenarios..."
if [ -z "$1" ]; then
    ./generate-scenarios
else
    ./generate-scenarios "$1"
fi

# Step 2: Shift arguments to remove the first argument (number of scenarios)
shift

# Step 3: Activate the virtual environment and run the main script
echo "Activating the virtual environment..."
source .venv/bin/activate

# Step 4: Run the main script with all provided arguments
echo "Running the main script with generated scenarios..."
python base.py "$@"

# Step 5: Deactivate the virtual environment
deactivate

echo "Execution complete!"

---

file: scenario.json
---
{
    "scenarios": [
      {
        "name": "Growing Polygon",
        "shape": "polygon",
        "size_change": 0,
        "sides_change": 1,
        "duration": 10,
        "rect_x": 100,
        "rect_y": 100,
        "rect_width": 440,
        "rect_height": 280,
        "speed_increase_factor": 1.01,
        "growth_rate": 0.1,
        "carrying_capacity": 200
      }
    ]
  }
---

file: scenarios.json
---
{
    "scenarios": [
        {
            "name": "Scenario 438",
            "duration": 15,
            "rect_x": 53,
            "rect_y": 141,
            "rect_width": 442,
            "rect_height": 237,
            "shapes": [
                {
                    "shape": "circle",
                    "color_change": true,
                    "size_change": -2.76,
                    "speed_increase_factor": 1.03,
                    "growth_rate": 0.03,
                    "carrying_capacity": 287.5,
                    "sides_change": 2,
                    "position_change": false,
                    "initial_size": 23.84,
                    "initial_speed_x": 6.07,
                    "initial_speed_y": 3.22
                },
                {
                    "shape": "circle",
                    "color_change": true,
                    "size_change": 4.82,
                    "speed_increase_factor": 1.03,
                    "growth_rate": 0.02,
                    "carrying_capacity": 187.28,
                    "sides_change": 3,
                    "position_change": true,
                    "initial_size": 42.29,
                    "initial_speed_x": 9.21,
                    "initial_speed_y": 2.56
                },
                {
                    "shape": "rectangle",
                    "color_change": true,
                    "size_change": 1.68,
                    "speed_increase_factor": 1.02,
                    "growth_rate": 0.03,
                    "carrying_capacity": 58.21,
                    "sides_change": 2,
                    "position_change": false,
                    "initial_size": 19.35,
                    "initial_speed_x": 8.75,
                    "initial_speed_y": 1.38
                },
                {
                    "shape": "rectangle",
                    "color_change": true,
                    "size_change": 0.76,
                    "speed_increase_factor": 1.04,
                    "growth_rate": 0.06,
                    "carrying_capacity": 229.35,
                    "sides_change": 0,
                    "position_change": false,
                    "initial_size": 21.83,
                    "initial_speed_x": 9.86,
                    "initial_speed_y": 2.81
                }
            ]
        }
    ]
}
---

file: shape.py
---
import random
import math
import logging
import asyncio
from datetime import datetime

from pydub.generators import Sine

# Set up the logger
logger = logging.getLogger('shape_collision_logger')
logger.setLevel(logging.INFO)
fh = logging.FileHandler('shape_collisions.log')
fh.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(message)s')
fh.setFormatter(formatter)
logger.addHandler(fh)

# Define some random notes (frequencies in Hz)
NOTES = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88]  # C4, D4, E4, F4, G4, A4, B4

class Shape:
    shape_counter = 0

    def __init__(self, config):
        Shape.shape_counter += 1
        self.identifier = Shape.shape_counter
        self.shape = config["shape"]
        self.size = float(config.get("initial_size", 20))
        self.speed = [float(config.get("initial_speed_x", 5)), float(config.get("initial_speed_y", 5))]
        self.position = [random.randint(int(self.size), 640 - int(self.size)), random.randint(int(self.size), 480 - int(self.size))]
        self.color = (255, 255, 255)
        self.sides = 3 if self.shape == 'polygon' else None
        self.color_change = config.get("color_change", False)
        self.size_change = config.get("size_change", 0)
        self.sides_change = config.get("sides_change", 0)
        self.speed_increase_factor = float(config.get("speed_increase_factor", 1.01))
        self.growth_rate = float(config.get("growth_rate", 0.1))
        self.carrying_capacity = float(config.get("carrying_capacity", 300))
        self.collisions = []
        self.note = random.choice(NOTES)

    def move(self):
        self.position[0] += self.speed[0]
        self.position[1] += self.speed[1]

    async def log_collision(self):
        log_message = f"Shape ID: {self.identifier} hit the boundary with note {self.note}"
        logger.info(log_message)
        self.collisions.append((datetime.now(), self.identifier, self.note))

    async def bounce(self, boundary):
        collision = False
        max_size = min(boundary.width, boundary.height) / 2

        if self.position[0] - self.size <= boundary.x:
            self.speed[0] = abs(self.speed[0]) * self.speed_increase_factor
            self.position[0] = boundary.x + self.size
            self.change_properties(max_size)
            await self.log_collision()
            collision = True
        elif self.position[0] + self.size >= boundary.x + boundary.width:
            self.speed[0] = -abs(self.speed[0]) * self.speed_increase_factor
            self.position[0] = boundary.x + boundary.width - self.size
            self.change_properties(max_size)
            await self.log_collision()
            collision = True
        
        if self.position[1] - self.size <= boundary.y:
            self.speed[1] = abs(self.speed[1]) * self.speed_increase_factor
            self.position[1] = boundary.y + self.size
            self.change_properties(max_size)
            await self.log_collision()
            collision = True
        elif self.position[1] + self.size >= boundary.y + boundary.height:
            self.speed[1] = -abs(self.speed[1]) * self.speed_increase_factor
            self.position[1] = boundary.y + boundary.height - self.size
            self.change_properties(max_size)
            await self.log_collision()
            collision = True

        return collision

    def change_properties(self, max_size):
        if self.color_change:
            self.color = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
        if self.size_change != 0:
            self.size += self.growth_rate * self.size * (1 - self.size / self.carrying_capacity)
        self.size = min(max(10, self.size), max_size)
        if self.sides is not None:
            self.sides = min(12, self.sides + self.sides_change)

    def get_collisions(self):
        return self.collisions

---

file: sound.py
---
from pydub import AudioSegment
from pydub.generators import Sine
from datetime import datetime

def foo(collision_data):
    if not collision_data:
        return

    # Calculate the total duration of the sound based on the last collision timestamp
    start_time = collision_data[0][0]
    end_time = collision_data[-1][0]
    total_duration_ms = int((end_time - start_time).total_seconds() * 1000) + 1000  # Add 1 second buffer

    combined = AudioSegment.silent(duration=total_duration_ms)

    for collision in collision_data:
        time, shape_id, note = collision
        start_time_ms = int((time - start_time).total_seconds() * 1000)  # calculate start time in ms
        sine_wave = Sine(note).to_audio_segment(duration=100).apply_gain(-3)  # Generate a sine wave for the note
        combined = combined.overlay(sine_wave, position=start_time_ms)

    combined.export("collision_sounds.wav", format="wav")

def print_collisions(collision_data):
    for data in collision_data:
        print(f"Time: {data[0]}, Shape ID: {data[1]}, Note: {data[2]}")

---

file: README.md
---
# Bouncing Shapes with Sound

This project simulates bouncing shapes within a defined boundary. Each shape is assigned a unique piano note that plays when the shape collides with the boundary. The shapes can grow, change color, and vary in speed. The game speed adjusts dynamically based on CPU usage to prevent crashes.

## Table of Contents

- [Features](#features)
- [Prerequisites](#prerequisites)
- [Installation](#installation)
- [Usage](#usage)
- [Directory Structure](#directory-structure)
- [Configuration](#configuration)
- [Scripts](#scripts)
- [Contributing](#contributing)
- [License](#license)

## Features

- Simulates multiple shapes (circle, rectangle, polygon) bouncing within a boundary.
- Shapes can grow, change color, and vary in speed.
- Each shape is assigned a unique piano note that plays upon collision with the boundary.
- Supports generating random scenarios with customizable parameters.
- Ability to record the simulation.
- Dynamic game speed adjustment based on CPU usage to prevent crashes.

## Prerequisites

- Python 3.7+
- `pydub` library
- `psutil` library
- `ffmpeg` for audio processing

## Installation

1. **Clone the repository:**

    ```bash
    git clone https://github.com/yourusername/bouncing-shapes-with-sound.git
    cd bouncing-shapes-with-sound
    ```

2. **Create a virtual environment and activate it:**

    ```bash
    python -m venv .venv
    source .venv/bin/activate
    ```

3. **Install the required packages:**

    ```bash
    pip install pydub numpy psutil
    ```

4. **Install `ffmpeg`:**
    - **On macOS:**
      ```bash
      brew install ffmpeg
      ```
    - **On Ubuntu:**
      ```bash
      sudo apt-get install ffmpeg
      ```
    - **On Windows:**
      Download and install `ffmpeg` from [ffmpeg.org](https://ffmpeg.org/download.html).

## Usage

### Running the Simulation

- **Run with default settings:**

    ```bash
    ./run
    ```

- **Run and generate random scenarios:**

    ```bash
    ./run-random
    ```

- **Run and generate a specific number of random scenarios:**

    ```bash
    ./run-random 20
    ```

- **Run with recording enabled:**

    ```bash
    ./run --record
    ```

### Generating Scenarios

- **Generate default number of scenarios (10):**

    ```bash
    ./generate-scenarios
    ```

- **Generate a specific number of scenarios:**

    ```bash
    ./generate-scenarios 20
    ```

## Directory Structure

```
bouncing-shapes-with-sound/
├── .venv/
├── base.py
├── boundary.py
├── display.py
├── generate-scenarios
├── generate_scenarios.py
├── README.md
├── recorder.py
├── run
├── run-random
├── scenarios.json
├── shape.py
└── sound.py
```

## Configuration

### `scenarios.json`

Each scenario in `scenarios.json` defines the boundary and shapes with their respective properties.

#### Example:

```json
{
    "scenarios": [
        {
            "name": "Scenario 1",
            "duration": 10,
            "rect_x": 100,
            "rect_y": 100,
            "rect_width": 400,
            "rect_height": 300,
            "shapes": [
                {
                    "shape": "circle",
                    "color_change": true,
                    "size_change": 2.5,
                    "speed_increase_factor": 1.03,
                    "growth_rate": 0.05,
                    "carrying_capacity": 250,
                    "sides_change": 0,
                    "initial_size": 30.0,
                    "initial_speed_x": 2.0,
                    "initial_speed_y": 3.0
                },
                {
                    "shape": "rectangle",
                    "color_change": false,
                    "size_change": 1.5,
                    "speed_increase_factor": 1.02,
                    "growth_rate": 0.04,
                    "carrying_capacity": 200,
                    "sides_change": 0,
                    "initial_size": 25.0,
                    "initial_speed_x": 3.0,
                    "initial_speed_y": 2.5
                }
            ]
        }
    ]
}
```

### Shape Properties

- `shape`: Type of shape (`circle`, `rectangle`, `polygon`).
- `color_change`: Whether the shape changes color upon collision.
- `size_change`: Amount by which the shape's size changes.
- `speed_increase_factor`: Factor by which the shape's speed increases upon collision.
- `growth_rate`: Rate at which the shape grows.
- `carrying_capacity`: Maximum size the shape can grow to.
- `sides_change`: Number of sides to change for polygons.
- `initial_size`: Initial size of the shape.
- `initial_speed_x`: Initial speed in the x-direction.
- `initial_speed_y`: Initial speed in the y-direction.

## Scripts

- `generate-scenarios`: Generates random scenarios.
- `run`: Runs the main script.
- `run-random`: Generates random scenarios and runs the main script.

## Contributing

1. Fork the repository.
2. Create a new branch: `git checkout -b feature-branch`.
3. Make your changes and commit them: `git commit -m 'Add some feature'`.
4. Push to the branch: `git push origin feature-branch`.
5. Open a pull request.

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.
---

file: base.py
---
import argparse
import json
import os
import time
from display import Display
from shape import Shape
from boundary import Boundary
from recorder import Recorder
from sound import foo, print_collisions
import psutil
import asyncio

def load_scenarios(file_path):
    with open(file_path, 'r') as file:
        data = json.load(file)
    return data["scenarios"]

async def run_scenario(config, output_dir, record, include_sound):
    display = Display(640, 480)
    boundary = Boundary(config["rect_x"], config["rect_y"], config["rect_width"], config["rect_height"])
    
    shapes = [Shape(shape_config) for shape_config in config["shapes"]]
    
    recorder = None
    output_file = None
    if record:
        output_file = os.path.join(output_dir, config["name"] + ".mp4")
        recorder = Recorder(640, 480, output_file)

    start_time = time.time()
    base_fps = 100
    while display.running and (time.time() - start_time < config["duration"]):
        display.handle_events()
        
        fps = base_fps

        for shape in shapes:
            shape.move()
            await shape.bounce(boundary)
        frame = display.update_display(shapes, boundary)
        if record:
            recorder.record_frame(display.window)
        display.tick(fps)
    
    if record:
        recorder.release()
    display.stop()
    
    # Collect collision data and pass it to foo()
    collision_data = []
    for shape in shapes:
        collision_data.extend(shape.get_collisions())
    if include_sound:
        foo(collision_data)
    print_collisions(collision_data)
    
    # Combine the recorded video with the generated audio if sound is included
    if record and include_sound:
        audio_file = "collision_sounds.wav"
        final_output_file = os.path.join(output_dir, config["name"] + "_with_audio.mp4")
        recorder.combine_video_audio(audio_file, final_output_file)
    elif record:
        final_output_file = output_file

def main(config_file, output_dir, record, include_sound):
    os.makedirs(output_dir, exist_ok=True)
    scenarios = load_scenarios(config_file)
    for config in scenarios:
        asyncio.run(run_scenario(config, output_dir, record, include_sound))

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run bouncing object scenarios.")
    parser.add_argument('--config', type=str, default='scenarios.json', help='Path to the JSON configuration file.')
    parser.add_argument('--output', type=str, default='output', help='Directory to save the output videos.')
    parser.add_argument('--record', action='store_true', help='Specify this flag to record the simulation.')
    parser.add_argument('--sound', action='store_true', help='Include sound in the recorded video.')
    args = parser.parse_args()
    main(args.config, args.output, args.record, args.sound)

---

file: boundary.py
---
class Boundary:
    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height

---

file: display.py
---
import pygame
import math

class Display:
    def __init__(self, width, height):
        pygame.init()
        self.width, self.height = width, height
        self.window = pygame.display.set_mode((self.width, self.height))
        pygame.display.set_caption("Bouncing Object ASMR")
        self.background_color = (0, 0, 0)
        self.clock = pygame.time.Clock()
        self.running = True

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False

    def update_display(self, shapes, boundary):
        self.window.fill(self.background_color)
        # Draw the boundary
        pygame.draw.rect(self.window, (255, 255, 255), (boundary.x, boundary.y, boundary.width, boundary.height), 2)
        # Draw each shape within the boundary
        for shape in shapes:
            if shape.shape == 'circle':
                pygame.draw.circle(self.window, shape.color, [int(coord) for coord in shape.position], int(shape.size))
            elif shape.shape == 'rectangle':
                pygame.draw.rect(self.window, shape.color, (shape.position[0] - shape.size, shape.position[1] - shape.size, shape.size * 2, shape.size * 2))
            elif shape.shape == 'polygon' and shape.sides:
                points = self.calculate_polygon_points(shape.position, shape.size, shape.sides)
                pygame.draw.polygon(self.window, shape.color, points)
        pygame.display.flip()
        return self.window.copy()

    def calculate_polygon_points(self, position, size, sides):
        points = []
        angle = 360 / sides
        for i in range(sides):
            x = position[0] + size * math.cos(math.radians(angle * i))
            y = position[1] + size * math.sin(math.radians(angle * i))
            points.append((x, y))
        return points

    def tick(self, fps):
        self.clock.tick(fps)

    def stop(self):
        pygame.quit()

---

file: generate-scenarios
---
#!/bin/bash

# Step 1: Activate the virtual environment
echo "Activating the virtual environment..."
source .venv/bin/activate

# Step 2: Run the generate_scenarios.py script with the provided argument
echo "Generating scenarios..."
if [ -z "$1" ]; then
    python generate_scenarios.py
else
    python generate_scenarios.py "$1"
fi

# Step 3: Deactivate the virtual environment
deactivate

echo "Scenario generation complete!"

---

file: generate_scenarios.py
---
import json
import random
import argparse

def generate_random_shape():
    shapes = ['circle', 'rectangle', 'polygon']
    shape = {
        "shape": random.choice(shapes),
        "color_change": random.choice([True, False]),
        "size_change": round(random.uniform(-5.0, 5.0), 2),
        "speed_increase_factor": round(random.uniform(1.01, 1.05), 2),
        "growth_rate": round(random.uniform(0.01, 0.1), 2),
        "carrying_capacity": round(random.uniform(50.0, 300.0), 2),
        "sides_change": random.randint(0, 3),
        "position_change": random.choice([True, False]),
        "initial_size": round(random.uniform(10.0, 50.0), 2),
        "initial_speed_x": round(random.uniform(1.0, 10.0), 2),
        "initial_speed_y": round(random.uniform(1.0, 10.0), 2)
    }
    return shape

def generate_random_scenario():
    scenario = {
        "name": f"Scenario {random.randint(1, 1000)}",
        "duration": random.randint(5, 20),
        "rect_x": random.randint(50, 150),
        "rect_y": random.randint(50, 150),
        "rect_width": random.randint(300, 500),
        "rect_height": random.randint(200, 400),
        "shapes": [generate_random_shape() for _ in range(random.randint(1, 5))]
    }
    return scenario

def generate_scenarios(num_scenarios):
    scenarios = {"scenarios": [generate_random_scenario() for _ in range(num_scenarios)]}
    with open('scenarios.json', 'w') as file:
        json.dump(scenarios, file, indent=4)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate random scenarios for bouncing objects.")
    parser.add_argument('num_scenarios', type=int, nargs='?', default=1, help='Number of scenarios to generate.')
    args = parser.parse_args()
    generate_scenarios(args.num_scenarios)

---

file: install
---
#!/bin/bash

# Step 1: Check if Python 3.11 is installed
if ! command -v python3.11 &>/dev/null; then
    echo "Python 3.11 is not installed. Please install Python 3.11."
    exit 1
fi

# Step 2: Create a virtual environment using Python 3.11
echo "Creating a virtual environment with Python 3.11..."
python3.11 -m venv .venv

# Step 3: Activate the virtual environment
echo "Activating the virtual environment..."
source .venv/bin/activate

# Step 4: Install required packages
echo "Installing required packages..."
pip install --upgrade pip
pip install -r requirements.txt

# Step 5: Deactivate the virtual environment
deactivate

echo "Installation complete!"

---

file: recorder.py
---
import cv2
import numpy as np
import pygame
from moviepy.editor import VideoFileClip, AudioFileClip
import os

class Recorder:
    def __init__(self, width, height, output_file):
        self.width = width
        self.height = height
        self.output_file = output_file
        self.fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        self.video_writer = cv2.VideoWriter(output_file, self.fourcc, 30.0, (width, height))

    def record_frame(self, surface):
        frame = pygame.surfarray.array3d(surface)
        frame = np.rot90(frame, 3)
        frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
        self.video_writer.write(frame)

    def release(self):
        self.video_writer.release()

    def combine_video_audio(self, audio_file, final_output_file):
        video_clip = VideoFileClip(self.output_file)
        audio_clip = AudioFileClip(audio_file)
        final_clip = video_clip.set_audio(audio_clip)
        final_clip.write_videofile(final_output_file, codec='libx264', audio_codec='aac')
        
        # Delete the original video file after combining
        os.remove(self.output_file)

---

file: requirements.txt
---
numpy
opencv-python
pygame
pydub
psutil
moviepy

---

file: run
---
#!/bin/bash

# Step 1: Activate the virtual environment
echo "Activating the virtual environment..."
source .venv/bin/activate

# Step 2: Run the main script with all provided arguments
echo "Running the main script..."
python base.py "$@"

# Step 3: Deactivate the virtual environment
deactivate

echo "Execution complete!"

---

file: run-random
---
#!/bin/bash

# Step 1: Generate random scenarios
echo "Generating random scenarios..."
if [ -z "$1" ]; then
    ./generate-scenarios
else
    ./generate-scenarios "$1"
fi

# Step 2: Shift arguments to remove the first argument (number of scenarios)
shift

# Step 3: Activate the virtual environment and run the main script
echo "Activating the virtual environment..."
source .venv/bin/activate

# Step 4: Run the main script with all provided arguments
echo "Running the main script with generated scenarios..."
python base.py "$@"

# Step 5: Deactivate the virtual environment
deactivate

echo "Execution complete!"

---

file: scenario.json
---
{
    "scenarios": [
      {
        "name": "Growing Polygon",
        "shape": "polygon",
        "size_change": 0,
        "sides_change": 1,
        "duration": 10,
        "rect_x": 100,
        "rect_y": 100,
        "rect_width": 440,
        "rect_height": 280,
        "speed_increase_factor": 1.01,
        "growth_rate": 0.1,
        "carrying_capacity": 200
      }
    ]
  }
---

file: scenarios.json
---
{
    "scenarios": [
        {
            "name": "Scenario 438",
            "duration": 15,
            "rect_x": 53,
            "rect_y": 141,
            "rect_width": 442,
            "rect_height": 237,
            "shapes": [
                {
                    "shape": "circle",
                    "color_change": true,
                    "size_change": -2.76,
                    "speed_increase_factor": 1.03,
                    "growth_rate": 0.03,
                    "carrying_capacity": 287.5,
                    "sides_change": 2,
                    "position_change": false,
                    "initial_size": 23.84,
                    "initial_speed_x": 6.07,
                    "initial_speed_y": 3.22
                },
                {
                    "shape": "circle",
                    "color_change": true,
                    "size_change": 4.82,
                    "speed_increase_factor": 1.03,
                    "growth_rate": 0.02,
                    "carrying_capacity": 187.28,
                    "sides_change": 3,
                    "position_change": true,
                    "initial_size": 42.29,
                    "initial_speed_x": 9.21,
                    "initial_speed_y": 2.56
                },
                {
                    "shape": "rectangle",
                    "color_change": true,
                    "size_change": 1.68,
                    "speed_increase_factor": 1.02,
                    "growth_rate": 0.03,
                    "carrying_capacity": 58.21,
                    "sides_change": 2,
                    "position_change": false,
                    "initial_size": 19.35,
                    "initial_speed_x": 8.75,
                    "initial_speed_y": 1.38
                },
                {
                    "shape": "rectangle",
                    "color_change": true,
                    "size_change": 0.76,
                    "speed_increase_factor": 1.04,
                    "growth_rate": 0.06,
                    "carrying_capacity": 229.35,
                    "sides_change": 0,
                    "position_change": false,
                    "initial_size": 21.83,
                    "initial_speed_x": 9.86,
                    "initial_speed_y": 2.81
                }
            ]
        }
    ]
}
---

file: shape.py
---
import random
import math
import logging
import asyncio
from datetime import datetime

from pydub.generators import Sine

# Set up the logger
logger = logging.getLogger('shape_collision_logger')
logger.setLevel(logging.INFO)
fh = logging.FileHandler('shape_collisions.log')
fh.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(message)s')
fh.setFormatter(formatter)
logger.addHandler(fh)

# Define some random notes (frequencies in Hz)
NOTES = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88]  # C4, D4, E4, F4, G4, A4, B4

class Shape:
    shape_counter = 0

    def __init__(self, config):
        Shape.shape_counter += 1
        self.identifier = Shape.shape_counter
        self.shape = config["shape"]
        self.size = float(config.get("initial_size", 20))
        self.speed = [float(config.get("initial_speed_x", 5)), float(config.get("initial_speed_y", 5))]
        self.position = [random.randint(int(self.size), 640 - int(self.size)), random.randint(int(self.size), 480 - int(self.size))]
        self.color = (255, 255, 255)
        self.sides = 3 if self.shape == 'polygon' else None
        self.color_change = config.get("color_change", False)
        self.size_change = config.get("size_change", 0)
        self.sides_change = config.get("sides_change", 0)
        self.speed_increase_factor = float(config.get("speed_increase_factor", 1.01))
        self.growth_rate = float(config.get("growth_rate", 0.1))
        self.carrying_capacity = float(config.get("carrying_capacity", 300))
        self.collisions = []
        self.note = random.choice(NOTES)

    def move(self):
        self.position[0] += self.speed[0]
        self.position[1] += self.speed[1]

    async def log_collision(self):
        log_message = f"Shape ID: {self.identifier} hit the boundary with note {self.note}"
        logger.info(log_message)
        self.collisions.append((datetime.now(), self.identifier, self.note))

    async def bounce(self, boundary):
        collision = False
        max_size = min(boundary.width, boundary.height) / 2

        if self.position[0] - self.size <= boundary.x:
            self.speed[0] = abs(self.speed[0]) * self.speed_increase_factor
            self.position[0] = boundary.x + self.size
            self.change_properties(max_size)
            await self.log_collision()
            collision = True
        elif self.position[0] + self.size >= boundary.x + boundary.width:
            self.speed[0] = -abs(self.speed[0]) * self.speed_increase_factor
            self.position[0] = boundary.x + boundary.width - self.size
            self.change_properties(max_size)
            await self.log_collision()
            collision = True
        
        if self.position[1] - self.size <= boundary.y:
            self.speed[1] = abs(self.speed[1]) * self.speed_increase_factor
            self.position[1] = boundary.y + self.size
            self.change_properties(max_size)
            await self.log_collision()
            collision = True
        elif self.position[1] + self.size >= boundary.y + boundary.height:
            self.speed[1] = -abs(self.speed[1]) * self.speed_increase_factor
            self.position[1] = boundary.y + boundary.height - self.size
            self.change_properties(max_size)
            await self.log_collision()
            collision = True

        return collision

    def change_properties(self, max_size):
        if self.color_change:
            self.color = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
        if self.size_change != 0:
            self.size += self.growth_rate * self.size * (1 - self.size / self.carrying_capacity)
        self.size = min(max(10, self.size), max_size)
        if self.sides is not None:
            self.sides = min(12, self.sides + self.sides_change)

    def get_collisions(self):
        return self.collisions

---

file: sound.py
---
from pydub import AudioSegment
from pydub.generators import Sine
from datetime import datetime

def foo(collision_data):
    if not collision_data:
        return

    # Calculate the total duration of the sound based on the last collision timestamp
    start_time = collision_data[0][0]
    end_time = collision_data[-1][0]
    total_duration_ms = int((end_time - start_time).total_seconds() * 1000) + 1000  # Add 1 second buffer

    combined = AudioSegment.silent(duration=total_duration_ms)

    for collision in collision_data:
        time, shape_id, note = collision
        start_time_ms = int((time - start_time).total_seconds() * 1000)  # calculate start time in ms
        sine_wave = Sine(note).to_audio_segment(duration=100).apply_gain(-3)  # Generate a sine wave for the note
        combined = combined.overlay(sine_wave, position=start_time_ms)

    combined.export("collision_sounds.wav", format="wav")

def print_collisions(collision_data):
    for data in collision_data:
        print(f"Time: {data[0]}, Shape ID: {data[1]}, Note: {data[2]}")

---

